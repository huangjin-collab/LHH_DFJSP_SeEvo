```python
import numpy as np

def get_combined_expression_v2(
    pt: np.ndarray,
    wkr: np.ndarray,
    rm: np.ndarray,
    so: np.ndarray,
    twk: np.ndarray,
    ema: np.ndarray
) -> np.ndarray:
    """
    Mutated composite priority function for JSP scheduling heuristics (v2):
    - Applies scale-invariant normalization via total workload,
    - Smooth nonlinearities with tanh and logistic for refined prioritization,
    - Adaptive alpha blending urgency and lookahead terms with EMA sign and magnitude,
    - Lookahead encapsulates a softened future operation anticipation with workload modulation,
    - Penalty implements volatility dampening with nonlinear softening keyed by urgency,
    - Final combined output bounded by tanh for stability and consistent priority scale,
    - Enhanced nonlinear lookahead and penalty terms provide smoother, more robust scheduling cues.

    Args:
        pt (np.ndarray): Processing time of current operation for all workpieces.
        wkr (np.ndarray): Remaining processing time for all workpieces including current operation.
        rm (np.ndarray): Remaining processing time for all workpieces excluding current operation.
        so (np.ndarray): Processing time of succeeding operation for all workpieces.
        twk (np.ndarray): Total processing time for all workpieces.
        ema (np.ndarray): Exponential Moving Average of relative deviation (realised vs nominal).

    Returns:
        np.ndarray: Composite priority scores; higher values indicate higher dispatch priority.
    """
    eps = 1e-14

    # Guard total workload to avoid division by zero
    safe_twk = np.maximum(twk, eps)

    # Scale invariant normalization
    norm_pt = pt / safe_twk
    norm_wkr = wkr / safe_twk
    norm_rm = rm / safe_twk
    norm_so = so / safe_twk

    # Clip EMA for directional insight preserving sign and limit extreme volatility
    ema_clipped = np.clip(ema, -1.0, 1.0)
    abs_ema = np.abs(ema_clipped)

    # Sharpen workload scaling around median for urgency modulation (logistic with steep slope)
    workload_scaled = 1 / (1 + np.exp(-9 * (norm_wkr - 0.3)))  # midpoint shifted slight for reaction

    # Adaptive alpha: blend urgency and lookahead with nonlinear dependence on EMA magnitude and workload
    alpha_base = 0.48 + 0.4 * (1.0 - abs_ema)  # base between ~0.48 and 0.88
    alpha = alpha_base + 0.12 * workload_scaled
    alpha = np.clip(alpha, 0.50, 0.93)  # slightly narrower range than v1

    # Residual normalized workload fraction capped for urgency term stability
    residual_work = np.clip(1.0 - norm_rm, 0.0, 1.0)

    # Urgency favors quick operations and clearing backlog with nonlinear scaling via tanh and power
    urgency_raw = residual_work / (norm_pt + eps)
    urgency = np.tanh(1.9 * (urgency_raw ** 1.25))  # sharpened exponent for more nonlinearity

    # Lookahead incorporates successor operation, modulated by workload and EMA sign:
    # - Use a smooth gating sigmoid on EMA sign for smooth transition effect
    ema_pos = 1 / (1 + np.exp(-20*(ema_clipped)))  # sigmoid approx step at 0
    ema_neg = 1 - ema_pos

    # Adjust lookahead weighting based on EMA sign with softened exponential decay factor on workload
    lookahead = norm_so * workload_scaled * (0.55 * (1 - ema_pos) + 0.35 * ema_neg)

    # Penalty softened nonlinearly by urgency and EMA magnitude, emphasizing volatility damping but sparing urgent tasks
    penalty_base = abs_ema * np.power(workload_scaled, 1.4)
    penalty = penalty_base * np.exp(-2.5 * urgency)

    # Final combined score blends urgency and lookahead minus penalty, bounded with tanh for numerical stability
    combined_raw = alpha * urgency + (1.0 - alpha) * lookahead - 0.84 * penalty
    combined = np.tanh(combined_raw)

    return combined
```
