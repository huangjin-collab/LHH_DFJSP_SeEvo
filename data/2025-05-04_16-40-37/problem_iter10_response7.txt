```python
import numpy as np

def get_combined_expression_v2(pt: np.ndarray, wkr: np.ndarray, rm: np.ndarray, so: np.ndarray, twk: np.ndarray, ema: np.ndarray) -> np.ndarray:
    """
    Mutated composite expression for JSP scheduling with enhanced smooth nonlinear transforms,
    stable normalization, and EMA-adaptive weighting.

    Improvements over v1:
    - Use sigmoid instead of tanh for smoother EMA weighting in [0,1].
    - Apply softplus transform on pt and wkr for smoothing positive-valued inputs.
    - Blend lookahead terms multiplicatively with sigmoid-scaled EMA weights.
    - Penalize volatility with exp decay on squared EMA for stronger punishment on fluctuations.
    - Normalize all components by (1 + EMA) to softly scale down volatile entries.
    """
    EPS = 1e-12

    # Safe normalization denominator
    twk_safe = np.maximum(twk, EPS)

    # Normalize inputs relative to total workload
    norm_pt = pt / twk_safe
    norm_wkr = wkr / twk_safe
    norm_rm = rm / twk_safe
    norm_so = so / twk_safe

    # Smooth positive transforms to reduce noise spikes
    smooth_pt = np.log1p(np.maximum(norm_pt, 0))
    smooth_wkr = np.log1p(np.maximum(norm_wkr, 0))

    # Sigmoid function for EMA weighting (range ~[0,1]), sharper than tanh around 0
    sigmoid_ema = 1 / (1 + np.exp(-10 * ema))

    # Geometric mean lookahead with softplus neighborhood and epsilon stability
    lookahead_geom = np.sqrt((norm_so + EPS) * (norm_rm + EPS))

    # Softly blend lookahead terms with sigmoid EMA weights multiplicatively
    lookahead = (lookahead_geom ** (1 - sigmoid_ema)) * (norm_so ** sigmoid_ema)

    # Dynamic weighting factors modulated by sigmoid_ema
    curr_weight = 0.55 + 0.45 * (1 - sigmoid_ema)
    wkr_weight = 0.4
    look_weight = 0.7 + 0.3 * sigmoid_ema

    # Base components multiplied by their weights
    base_curr = smooth_pt * curr_weight
    base_wkr = smooth_wkr * wkr_weight
    base_look = lookahead * look_weight

    # Exponentially punish squared EMA volatility for robustness
    volatility_penalty = np.exp(-5 * (ema ** 2))

    # Soft scaling down by (1 + EMA) to reduce impact of unstable operations
    scale_down = 1 / (1 + ema)

    # Final combined heuristic expression
    combined = (base_curr + base_wkr + base_look) * volatility_penalty * scale_down

    # Add a mild EMA-weighted boost on smooth_pt to keep gradient sensitivity
    combined += 0.25 * sigmoid_ema * smooth_pt

    return combined
```
