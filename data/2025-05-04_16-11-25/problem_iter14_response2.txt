```python
import numpy as np

def get_combined_expression_v2(
    pt: np.ndarray,
    wkr: np.ndarray,
    rm: np.ndarray,
    so: np.ndarray,
    twk: np.ndarray,
    ema: np.ndarray,
) -> np.ndarray:
    """
    Enhanced JSP scheduling heuristic that refines nonlinear scaling,
    EMA modulation, urgency prioritization, and adaptive penalty terms
    with an emphasis on numerical stability, smooth transitions and interpretability.

    Args:
        pt (np.ndarray): Processing time of current operation per workpiece.
        wkr (np.ndarray): Remaining processing time including current operation.
        rm (np.ndarray): Remaining processing time excluding current operation.
        so (np.ndarray): Processing time of succeeding operation per workpiece.
        twk (np.ndarray): Total processing time per workpiece.
        ema (np.ndarray): EMA of relative deviation ((realized/nominal) - 1) per workpiece.

    Returns:
        np.ndarray: Composite priority score array; lower values indicate higher priority.
    """
    eps = 1e-16
    twk_safe = twk + eps

    # Normalize time-based inputs tightly to prevent scale issues
    pt_n = pt / twk_safe
    so_n = so / twk_safe
    wkr_n = wkr / twk_safe
    rm_n = rm / twk_safe

    # --- Nonlinear scaling with smooth polynomial blends ---
    # Smoothly emphasize moderate pt and so values to enhance discriminative power
    pt_pow = np.power(pt_n + eps, 1.18)  # Slightly stronger than linear
    so_pow = np.power(so_n + eps, 0.88)  # Slightly sublinear, favoring smaller values
    nonlinear_load = pt_pow + so_pow

    # --- EMA modulation ---
    # Scale, smooth and bound EMA values to softly regulate influence of variability
    ema_scaled = 1.15 * ema / (1.0 + 1.15 * np.abs(ema))                # compress range roughly to [-1,1]
    ema_tanh = np.tanh(ema_scaled * 1.3) * 0.88                        # soft tanh shaping and scaling
    ema_blend = 0.65 * ema_scaled + 0.35 * ema_tanh                    # linear+nonlinear blend for smoothness
    # Map to robust modulation factor in [0.45, 1.55]
    var_factor = np.clip(1.0 + 0.55 * ema_blend, 0.45, 1.55)

    # --- Urgency prioritization ---
    # Remaining workload fraction relevant to current op, ensure non-negative domain
    urgency_comp = np.maximum(wkr_n - rm_n, 0.0)
    # Exponentially decaying urgency to focus on most pressing tasks, with mild base floor
    urgency_decay = 0.92 * np.exp(-4.5 * urgency_comp) + 0.08

    # --- Adaptive penalty for trivial operations ---
    # Balance penalty between geometric mean of pt & so and diminishing speed effect
    geom_mean = np.sqrt(pt_n * so_n + eps)
    speed_mod = 1.0 / (1.0 + 5.0 * pt_n)
    penalty_raw = 1.0 + 0.52 * geom_mean * speed_mod
    penalty = np.clip(penalty_raw, 0.68, 1.32)  # robust bounds to avoid extremes

    # --- Final composite score calculation ---
    score = (nonlinear_load * var_factor) / (penalty + eps)  # apply penalty as divisor
    score *= urgency_decay

    # Enforce non-negativity for numerical robustness and interpretability
    score = np.maximum(score, 0.0)

    return score
```
