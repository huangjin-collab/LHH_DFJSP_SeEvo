```python
import numpy as np

def get_combined_expression_v2(
    pt: np.ndarray,
    wkr: np.ndarray,
    rm: np.ndarray,
    so: np.ndarray,
    twk: np.ndarray,
    ema: np.ndarray
) -> np.ndarray:
    """
    Enhanced composite heuristic for JSP scheduling that normalizes inputs, applies nonlinear EMA weighting,
    incorporates sharper future load penalties via power terms, strengthens look-ahead importance,
    and smooths workload terms via logarithmic transforms.

    Parameters:
    - pt: processing time of current operation (shape: n_jobs,)
    - wkr: remaining processing time including current operation (shape: n_jobs,)
    - rm: remaining processing time excluding current operation (shape: n_jobs,)
    - so: processing time of succeeding operation (shape: n_jobs,)
    - twk: total processing time per workpiece (shape: n_jobs,)
    - ema: exponential moving average of relative deviations (shape: n_jobs,)

    Returns:
    - combined_expression_data: heuristic priority scores (shape: n_jobs,)
    """
    epsilon = 1e-12

    # Normalize times by total workload to prevent scaling issues
    pt_norm = pt / (twk + epsilon)
    wkr_norm = wkr / (twk + epsilon)
    rm_norm = rm / (twk + epsilon)
    so_norm = so / (twk + epsilon)

    # Nonlinear EMA weighting using tanh, scaling deviations between approx [0.4,1.6]
    ema_weight = 1 + 0.6 * np.tanh(4 * ema)
    
    # Sharper penalization for future load with fractional exponent >1 (1.7) for increased contrast
    future_load_penalty = rm_norm ** 1.7

    # Log-based smoothing of workload to moderate extremes, clipped to non-negative domain
    log_wkr = np.log1p(np.clip(wkr_norm, 0, None))
    log_rm = np.log1p(np.clip(rm_norm, 0, None))

    # Amplified look-ahead factor: cube of normalized successor time weighted by EMA inverse,
    # emphasizing stable jobs and quick successors more strongly
    lookahead = (so_norm ** 3) * np.exp(-1.5 * ema)

    # Compose combined expression prioritizing:
    # - current operation scaled by dynamic EMA and inverse future load penalty
    # - strong look-ahead to fast successors with stability scaling
    # - workload terms penalized logarithmically and modulated by EMA magnitude/powers
    combined_expression_data = (
        pt_norm * ema_weight * (1 - future_load_penalty)
        + 4.5 * lookahead
        - 1.0 * log_wkr * np.abs(ema) * 0.9
        - 1.6 * log_rm * (ema ** 2)
    )

    return combined_expression_data
```
