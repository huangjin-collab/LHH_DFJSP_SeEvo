```python
import numpy as np

def get_combined_expression_v2(
    pt: np.ndarray,
    wkr: np.ndarray,
    rm: np.ndarray,
    so: np.ndarray,
    twk: np.ndarray,
    ema: np.ndarray
) -> np.ndarray:
    eps = 1e-8

    # Normalize inputs by total workload to retain comparability
    norm_pt = pt / (twk + eps)
    norm_wkr = wkr / (twk + eps)
    norm_rm = rm / (twk + eps)
    norm_so = so / (twk + eps)

    # Nonlinear smoothing transforms to reduce impact of outliers and emphasize mid-range differences
    sqrt_rm = np.sqrt(np.maximum(norm_rm, 0))
    sqrt_so = np.sqrt(np.maximum(norm_so, 0))
    sqrt_wkr = np.sqrt(np.maximum(norm_wkr, 0))
    sqrt_pt = np.sqrt(np.maximum(norm_pt, 0))

    # Sigmoid transform for EMA to smoothly punish excess positive deviations,
    # shifting EMA so that small negative deviations are near 0.5
    k = 12
    shift = 0.05
    sigmoid_ema = 1.0 / (1.0 + np.exp(-k * (ema - shift)))

    # Logarithmic scaling for total workload to moderate impact of very large workloads
    log_twk = np.log1p(twk)

    # Dynamic penalty blending workload variability (rm + so) and EMA-driven uncertainty,
    # emphasizing the uncertainty more for higher EMA values
    penalty = sigmoid_ema * (sqrt_rm + sqrt_so) * (1 + 0.6 * log_twk)

    # Lookahead factor balances expected delay risk from successor operation and remaining minus current proc time
    diff_rm_pt = (rm - pt)
    denom_diff = 1 + np.abs(diff_rm_pt)
    lookahead = sqrt_so * diff_rm_pt / denom_diff

    # EMA weighted urgency modifier emphasizing overrun risk smoothly above zero EMA
    ema_urgency = 1 + 0.7 * np.tanh(ema * 3)

    # Finishing urgency boost: promotes operations with very low remaining time on current job
    finishing_boost = 0.08 / (norm_rm + 0.15)

    # Combine:
    # - Immediate urgency from current proc time and workload scaled by EMA urgency factor
    # - Lookahead adjusted by penalty and EMA to anticipate downstream impact
    # - Subtract moderate penalty to avoid risk-prone jobs dominating
    # - Add finishing boost to prioritize close-to-finish jobs
    composite = (
        sqrt_pt * sqrt_wkr * ema_urgency +
        lookahead * penalty * (1 + ema * 0.8) -
        penalty * 0.3 +
        finishing_boost
    )

    return composite
```
