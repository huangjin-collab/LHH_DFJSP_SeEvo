```python
import numpy as np

def get_combined_expression_v2(pt: np.ndarray, wkr: np.ndarray, rm: np.ndarray, so: np.ndarray, twk: np.ndarray, ema: np.ndarray) -> np.ndarray:
    epsilon = 1e-8

    # Robust scale-invariant normalization: normalize all variables by max with epsilon
    pt_n = pt / (np.max(pt) + epsilon)
    wkr_n = wkr / (np.max(wkr) + epsilon)
    rm_n = rm / (np.max(rm) + epsilon)
    so_n = so / (np.max(so) + epsilon)
    twk_n = twk / (np.max(twk) + epsilon)
    ema_n = ema / (np.max(np.abs(ema)) + epsilon)

    # Smooth sign-aware nonlinear transform: signed sqrt for wkr and rm differences (preserve sign)
    def signed_sqrt(x):
        return np.sign(x) * np.sqrt(np.abs(x))

    progress = signed_sqrt(rm_n - wkr_n)

    # Dynamic EMA weight with adaptive decay: weight factor reduced when EMA deviation is small (clip and invert scale)
    ema_abs = np.abs(ema_n)
    ema_weight = np.clip(np.exp(ema_n) * (1 + ema_n**2), 1.0, 10.0)
    adapt_weight = np.where(ema_abs < 0.05, 0.5, 1.0)  # downscale when stable (small dev)

    # Look-ahead mechanism with smooth sigmoid modulation to reduce extreme influence
    sigmoid = lambda x: 1 / (1 + np.exp(-12 * (x - 0.5)))  # steep sigmoid around 0.5
    look_ahead_factor = sigmoid(so_n)
    look_ahead = so_n * (1 + (ema_weight**1.1) * adapt_weight) * look_ahead_factor

    # Stability factor: clip EMA norm to avoid division by near zero, penalize volatile jobs smoothly
    stability_denom = 1 + np.abs(ema_n)**1.5 + epsilon
    stability = (twk_n - wkr_n) / stability_denom
    stability = np.clip(stability, 0, 10)

    # Adaptive priority balancing: multiplicative-additive blend with nonlinear transforms and clipping for stability
    combined = (
        pt_n * (1 + 0.75 * ema_weight * adapt_weight)  # weighted processing time
        + look_ahead                                   # look-ahead weighted
        - progress**3 * stability                      # cubic amplifies sign-sensitive progress with stability
    )

    # Final clipping to ensure priorities remain within stable range
    combined_clipped = np.clip(combined, -10, 10)

    return combined_clipped
```
