```python
import numpy as np

def get_combined_expression_v2(
    pt: np.ndarray,
    wkr: np.ndarray,
    rm: np.ndarray,
    so: np.ndarray,
    twk: np.ndarray,
    ema: np.ndarray
) -> np.ndarray:
    """
    Improved composite expression for JSP scheduling heuristics:
    - Uses smooth nonlinear transforms (tanh) on EMA and workload ratio
    - Adaptive alpha-beta blending weights via sigmoid on workload ratios
    - Polynomial stability measures to sharpen sensitivity
    - Balances urgency, bottleneck pressure, workload balance, and lookahead reward dynamically
    """

    eps = 1e-14
    twk_safe = twk + eps

    # Normalize inputs against total workload to ensure scale invariance
    norm_pt = pt / twk_safe
    norm_wkr = wkr / twk_safe
    norm_rm = rm / twk_safe
    norm_so = so / twk_safe

    # Clip and smooth EMA into [-1,1], using tanh for nonlinearity and stronger saturation
    bounded_ema = np.tanh(3 * np.clip(ema, -1, 1))

    # Workload ratio metric: normalized remaining work over current operation time
    workload_ratio_raw = norm_wkr / (norm_pt + eps)
    # Smooth sigmoid mapping workload ratio to [0.3,1] adaptive alpha weight 
    alpha = 0.3 + 0.7 / (1 + np.exp(-12 * (workload_ratio_raw - 1)))
    beta = 1.0 - alpha

    # High-order polynomial stability to sharpen weighting on stable EMA values
    stability = 1 + 4 * bounded_ema ** 6

    # Bottleneck pressure: importance of current + squared scaled succeeding op time,
    # increased by EMA absolute value nonlinearity to stress deviation impact
    bottleneck_pressure = norm_pt * (1 + 4 * norm_so**2) * (1 + 2.2 * np.abs(bounded_ema))

    # Urgency: normalized remaining work decayed by bottleneck pressure accounting for EMA effect
    urgency = norm_wkr * np.exp(-bottleneck_pressure * (1 - 0.55 * np.abs(bounded_ema)))

    # Workload balance penalizes disparity between total remaining and current op weighted by urgency and squared stability
    workload_balance = (norm_rm - norm_pt) * urgency * (stability ** 2)

    # Lookahead reward smooth and scaled by stability polynomials and EMA for future bottleneck anticipation
    lookahead_reward = norm_so * (1 + 1.7 * stability ** 1.5) * (1 + 0.62 * bounded_ema)

    # Final combined heuristic blending urgency, bottleneck, lookahead and balancing terms adaptively
    combined_expression = alpha * (workload_balance + lookahead_reward) + beta * bottleneck_pressure

    return combined_expression
```
