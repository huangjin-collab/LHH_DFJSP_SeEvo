```python
import numpy as np

def get_combined_expression_v2(
    pt: np.ndarray,
    wkr: np.ndarray,
    rm: np.ndarray,
    so: np.ndarray,
    twk: np.ndarray,
    ema: np.ndarray
) -> np.ndarray:
    """
    Improved composite heuristic expression for Job Shop Scheduling Problem, combining:
     - Sharper sigmoid-based smooth scaling with tuned thresholds for workload urgency and lookahead
     - EMA tightly clipped and scaled to modulate operation times and penalties gracefully
     - Balanced weighting of immediate, residual, and succeeding operation contributions
     - Adaptive nonlinear penalties for residual work emphasizing bottleneck relief
    """
    eps = 1e-9

    def sigmoid(x: np.ndarray, alpha: float=12.0, shift: float=0.4) -> np.ndarray:
        """Sharpened sigmoid emphasizing transition around 'shift' with steepness alpha."""
        return 1.0 / (1.0 + np.exp(-alpha * (x - shift)))

    # Clip EMA deviation within stable bounds: keeps multiplier near unity but allows moderate adaptation
    ema_clipped = np.clip(ema, -0.15, 0.15)  # slightly symmetric around zero for balanced scaling
    ema_factor = 1.0 + 3.5 * ema_clipped     # maps [-0.15,+0.15] to approx [0.475,1.525]

    # Normalize by total workload ensuring numerical stability
    twk_safe = np.maximum(twk, eps)

    norm_wkr = wkr / twk_safe          # fraction remaining workload including current operation
    norm_rm = rm / twk_safe            # fraction residual workload excluding current operation
    norm_so = so / twk_safe            # fraction succeeding operation workload

    # Urgency of immediate work: sharp transition emphasizing when workload exceeds ~35%
    urgency = sigmoid(norm_wkr, alpha=14.0, shift=0.35)

    # Lookahead importance based on succeeding operation workload fraction,
    # sharper threshold to activate only when successor is significant (>30%)
    lookahead_sig = sigmoid(norm_so, alpha=14.0, shift=0.3)

    # Residual workload proportion relative to total remaining -> influences penalty strength
    residual_ratio = rm / (wkr + eps)
    # Nonlinear penalty sharply decreasing as residual ratio approaches zero, promoting bottleneck clearing
    residual_penalty = 1.0 - sigmoid(residual_ratio, alpha=18.0, shift=0.25)

    # Compose the heuristic:
    # 1) Immediate processing time scaled by EMA factor and urgency
    immediate_component = pt * ema_factor * urgency

    # 2) Lookahead component scaled by EMA factor and backed by workload ratio balancing
    lookahead_component = so * ema_factor * lookahead_sig * (norm_wkr + 0.5 * norm_rm)

    # 3) Residual penalty applied multiplicatively with adaptive nonlinearity and EMA scaling,
    #    encouraging scheduling reducing the residual bottleneck
    residual_component = -1.8 * pt * residual_penalty * ema_factor

    combined = immediate_component + lookahead_component + residual_component

    return combined
```
